// Generated by CoffeeScript 1.12.3
(function() {
  var INITIAL_NODE, LRU, TERM_ACTION, TERM_STATE, UNKNOWN, _,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ = require('lodash');

  LRU = require('lru-cache');

  TERM_ACTION = '__TERM_ACTION__';

  TERM_STATE = '__TERM_STATE__';

  UNKNOWN = '__';

  INITIAL_NODE = '';

  module.exports = {
    update: function(obj, key, val) {
      var o;
      o = {};
      o[key] = val;
      return _.extend({}, obj, o);
    },
    updateList: function(lst, idx, val) {
      lst = lst.slice();
      lst[idx] = val;
      return lst;
    },
    buildEnv: function() {
      var addNode, address2idx, belief, getMoves, idx2address, initialState, layout, newLoc, transition, tree;
      getMoves = function(addr) {
        var last;
        last = parseInt(_.last(addr));
        switch (addr.length) {
          case 0:
            return [0, 1, 2, 3];
          case 1:
            return [last];
          case 2:
            return [(last + 1) % 4, (last + 3) % 4];
          case 3:
            return [];
          default:
            throw new Error('too long ' + addr);
        }
      };
      newLoc = function(loc, move) {
        var options, x, y;
        x = loc[0], y = loc[1];
        options = [[x, y + 1], [x + 1, y], [x, y - 1], [x - 1, y]];
        return options[move];
      };
      belief = function(addr) {
        if (addr === '') {
          return 0;
        } else {
          return UNKNOWN;
        }
      };
      tree = [];
      transition = [];
      initialState = [];
      idx2address = [];
      address2idx = {};
      layout = [];
      addNode = function(addr, loc) {
        var child, children, idx, j, len, m, moves, ref;
        address2idx[addr] = idx = tree.length;
        idx2address.push(addr);
        layout.push(loc);
        children = [];
        tree.push(children);
        moves = {};
        transition.push(moves);
        initialState.push(belief(addr));
        ref = getMoves(addr);
        for (j = 0, len = ref.length; j < len; j++) {
          m = ref[j];
          child = addNode(addr + m, newLoc(loc, m));
          children.push(child);
          moves[m] = child;
        }
        return idx;
      };
      addNode('', [0, 0]);
      return {
        initialState: initialState,
        transition: transition,
        tree: tree,
        layout: layout,
        idx2address: idx2address,
        address2idx: address2idx,
        hashState: function(state) {
          return state;
        }
      };
    },
    buildCross: function(branch, depth) {
      var env, hashCache;
      env = this.buildEnv([branch].concat(Array(depth - 1).fill(1)));
      hashCache = LRU(100000);
      env.hashState = function(state) {
        var s;
        if (state === TERM_STATE) {
          return state;
        } else {
          s = state;
          return [[s['0'], s['00'], s['000']].sort(), [s['1'], s['10'], s['100']].sort(), [s['2'], s['20'], s['200']].sort()].sort();
        }
      };
      return env;
    },
    firstUnobserved: function(acts) {
      var a, branch, depth, i, j, l, len, n, ref, ref1, result;
      depth = _.max((function() {
        var j, len, results;
        results = [];
        for (j = 0, len = acts.length; j < len; j++) {
          a = acts[j];
          results.push(a.length);
        }
        return results;
      })());
      result = [];
      ref = '0123456789';
      for (j = 0, len = ref.length; j < len; j++) {
        branch = ref[j];
        for (i = l = 0, ref1 = depth; 0 <= ref1 ? l < ref1 : l > ref1; i = 0 <= ref1 ? ++l : --l) {
          n = branch + ('0'.repeat(i));
          if (indexOf.call(acts, n) >= 0) {
            result.push(n);
            break;
          }
        }
      }
      return result;
    },
    cache: function(f, env, maxSize) {
      var c, cf, usage;
      if (maxSize == null) {
        maxSize = null;
      }
      c = LRU(maxSize);
      usage = 0;
      cf = function(s, k, a) {
        var args, newk, stringedArgs;
        args = Array.prototype.slice.call(arguments, 3);
        stringedArgs = JSON.stringify([env.hashState(args[0])].concat(args.slice(1)));
        if (c.has(stringedArgs)) {
          usage += 1;
          return k(s, c.get(stringedArgs));
        } else {
          newk = function(s, r) {
            if (c.has(stringedArgs)) {
              console.log('Already in cache:', stringedArgs);
              if (JSON.stringify(c.get(stringedArgs)) !== JSON.stringify(r)) {
                console.log('OLD AND NEW CACHE VALUE DIFFER!');
                console.log('Old value:', c.get(stringedArgs));
                console.log('New value:', r);
              }
            }
            c.set(stringedArgs, r);
            return k(s, r);
          };
          return f.apply(this, [s, newk, a].concat(args));
        }
      };
      cf.cache = c;
      return cf;
    },
    cacheFred: function(f, maxSize) {
      var c, cf, usage;
      if (maxSize == null) {
        maxSize = null;
      }
      console.log('cacheFred');
      c = LRU(maxSize);
      usage = 0;
      cf = function(s, k, a) {
        var args, newk, stringedArgs;
        args = Array.prototype.slice.call(arguments, 3);
        stringedArgs = JSON.stringify(args);
        if (c.has(stringedArgs)) {
          usage += 1;
          return k(s, c.get(stringedArgs));
        } else {
          newk = function(s, r) {
            if (c.has(stringedArgs)) {
              console.log('Already in cache:', stringedArgs);
              if (JSON.stringify(c.get(stringedArgs)) !== JSON.stringify(r)) {
                console.log('OLD AND NEW CACHE VALUE DIFFER!');
                console.log('Old value:', c.get(stringedArgs));
                console.log('New value:', r);
              }
            }
            c.set(stringedArgs, r);
            return k(s, r);
          };
          return f.apply(this, [s, newk, a].concat(args));
        }
      };
      cf.cache = c;
      return cf;
    }
  };

}).call(this);
