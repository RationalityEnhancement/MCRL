// Generated by CoffeeScript 1.12.6

/*
jspsych-mouselab-mdp.coffee
Fred Callaway

https://github.com/fredcallaway/Mouselab-MDP
 */
var D, SCORE, TIME_LEFT, WATCH, mdp,
  slice = [].slice,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

mdp = void 0;

D = void 0;

WATCH = {};

SCORE = 0;

TIME_LEFT = void 0;

jsPsych.plugins['mouselab-mdp'] = (function() {
  var Arrow, Edge, KEYS, LOG_DEBUG, LOG_INFO, MouselabMDP, NULL, PRINT, RIGHT_MESSAGE, SIZE, State, TOP_ADJUST, TRIAL_INDEX, Text, angle, checkObj, dist, plugin, polarMove, redGreen, removePrivate, round;
  PRINT = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return console.log.apply(console, args);
  };
  NULL = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return null;
  };
  LOG_INFO = PRINT;
  LOG_DEBUG = NULL;
  SIZE = void 0;
  TRIAL_INDEX = 0;
  TOP_ADJUST = -16;
  fabric.Object.prototype.originX = fabric.Object.prototype.originY = 'center';
  fabric.Object.prototype.selectable = false;
  fabric.Object.prototype.hoverCursor = 'plain';
  removePrivate = function(obj) {
    return _.pick(obj, (function(v, k, o) {
      return !k.startsWith('_');
    }));
  };
  angle = function(x1, y1, x2, y2) {
    var ang, x, y;
    x = x2 - x1;
    y = y2 - y1;
    if (x === 0) {
      ang = y === 0 ? 0 : y > 0 ? Math.PI / 2 : Math.PI * 3 / 2;
    } else if (y === 0) {
      ang = x > 0 ? 0 : Math.PI;
    } else {
      ang = x < 0 ? Math.atan(y / x) + Math.PI : y < 0 ? Math.atan(y / x) + 2 * Math.PI : Math.atan(y / x);
    }
    return ang + Math.PI / 2;
  };
  polarMove = function(x, y, ang, dist) {
    x += dist * Math.sin(ang);
    y -= dist * Math.cos(ang);
    return [x, y];
  };
  dist = function(o1, o2) {
    return Math.pow(Math.pow(o1.left - o2.left, 2) + Math.pow(o1.top - o2.top, 2), 0.5);
  };
  redGreen = function(val) {
    if (val > 0) {
      return '#080';
    } else if (val < 0) {
      return '#b00';
    } else {
      return '#666';
    }
  };
  round = function(x) {
    return (Math.round(x * 100)) / 100;
  };
  checkObj = function(obj, keys) {
    var i, k, len;
    if (keys == null) {
      keys = Object.keys(obj);
    }
    for (i = 0, len = keys.length; i < len; i++) {
      k = keys[i];
      if (obj[k] === void 0) {
        console.log('Bad Object: ', obj);
        throw new Error(k + " is undefined");
      }
    }
    return obj;
  };
  KEYS = mapObject({
    up: 'uparrow',
    down: 'downarrow',
    right: 'rightarrow',
    left: 'leftarrow',
    simulate: 'space'
  }, jsPsych.pluginAPI.convertKeyCharacterToKeyCode);
  RIGHT_MESSAGE = '\xa0'.repeat(8) + 'Score: <span id=mouselab-score/>';
  MouselabMDP = (function() {
    function MouselabMDP(config) {
      this.checkFinished = bind(this.checkFinished, this);
      this.endTrial = bind(this.endTrial, this);
      this.buildMap = bind(this.buildMap, this);
      this.initPlayer = bind(this.initPlayer, this);
      this.draw = bind(this.draw, this);
      this.run = bind(this.run, this);
      this.spendEnergy = bind(this.spendEnergy, this);
      this.drawScore = bind(this.drawScore, this);
      this.resetScore = bind(this.resetScore, this);
      this.addScore = bind(this.addScore, this);
      this.arrive = bind(this.arrive, this);
      this.recordQuery = bind(this.recordQuery, this);
      this.getEdgeLabel = bind(this.getEdgeLabel, this);
      this.mouseoutEdge = bind(this.mouseoutEdge, this);
      this.mouseoverEdge = bind(this.mouseoverEdge, this);
      this.clickEdge = bind(this.clickEdge, this);
      this.mouseoutState = bind(this.mouseoutState, this);
      this.mouseoverState = bind(this.mouseoverState, this);
      this.showFeedback = bind(this.showFeedback, this);
      this.clickState = bind(this.clickState, this);
      this.move = bind(this.move, this);
      this.getReward = bind(this.getReward, this);
      this.encodeBelief = bind(this.encodeBelief, this);
      this.getOutcome = bind(this.getOutcome, this);
      this.endSimulationMode = bind(this.endSimulationMode, this);
      this.startSimulationMode = bind(this.startSimulationMode, this);
      this.handleKey = bind(this.handleKey, this);
      this.startTimer = bind(this.startTimer, this);
      this.runDemo = bind(this.runDemo, this);
      var blockName, centerMessage, leftMessage, lowerMessage, prompt, ref, ref1, ref10, ref11, ref12, ref13, ref14, ref15, ref16, ref17, ref18, ref19, ref2, ref20, ref21, ref22, ref23, ref24, ref25, ref26, ref27, ref28, ref29, ref3, ref30, ref31, ref32, ref33, ref4, ref5, ref6, ref7, ref8, ref9, rightMessage, size, trial_id;
      this.display = config.display, this.graph = config.graph, this.layout = config.layout, this.initial = config.initial, this.stateLabels = (ref = config.stateLabels) != null ? ref : 'reward', this.stateDisplay = (ref1 = config.stateDisplay) != null ? ref1 : 'never', this.stateClickCost = (ref2 = config.stateClickCost) != null ? ref2 : 0, this.edgeLabels = (ref3 = config.edgeLabels) != null ? ref3 : 'never', this.edgeDisplay = (ref4 = config.edgeDisplay) != null ? ref4 : 'always', this.edgeClickCost = (ref5 = config.edgeClickCost) != null ? ref5 : 0, this.stateRewards = (ref6 = config.stateRewards) != null ? ref6 : null, this.clickDelay = (ref7 = config.clickDelay) != null ? ref7 : 0, this.moveDelay = (ref8 = config.moveDelay) != null ? ref8 : 500, this.clickEnergy = (ref9 = config.clickEnergy) != null ? ref9 : 0, this.moveEnergy = (ref10 = config.moveEnergy) != null ? ref10 : 0, this.startScore = (ref11 = config.startScore) != null ? ref11 : 0, this.actions = (ref12 = config.actions) != null ? ref12 : null, this.clicks = (ref13 = config.clicks) != null ? ref13 : null, this.pid = (ref14 = config.pid) != null ? ref14 : null, this.allowSimulation = (ref15 = config.allowSimulation) != null ? ref15 : false, this.revealRewards = (ref16 = config.revealRewards) != null ? ref16 : true, this.training = (ref17 = config.training) != null ? ref17 : false, this.special = (ref18 = config.special) != null ? ref18 : '', this.timeLimit = (ref19 = config.timeLimit) != null ? ref19 : null, this.minTime = (ref20 = config.minTime) != null ? ref20 : null, this.energyLimit = (ref21 = config.energyLimit) != null ? ref21 : null, this.qs = (ref22 = config.qs) != null ? ref22 : null, this.keys = (ref23 = config.keys) != null ? ref23 : KEYS, this.trialIndex = (ref24 = config.trialIndex) != null ? ref24 : TRIAL_INDEX, this.playerImage = (ref25 = config.playerImage) != null ? ref25 : 'static/images/plane.png', size = (ref26 = config.size) != null ? ref26 : 80, trial_id = (ref27 = config.trial_id) != null ? ref27 : null, blockName = (ref28 = config.blockName) != null ? ref28 : 'none', prompt = (ref29 = config.prompt) != null ? ref29 : '&nbsp;', leftMessage = (ref30 = config.leftMessage) != null ? ref30 : '&nbsp;', centerMessage = (ref31 = config.centerMessage) != null ? ref31 : '&nbsp;', rightMessage = (ref32 = config.rightMessage) != null ? ref32 : RIGHT_MESSAGE, lowerMessage = (ref33 = config.lowerMessage) != null ? ref33 : '&nbsp;';
      this.termAction = "" + this.stateRewards.length;
      if (this.pid != null) {
        this.showParticipant = true;
        centerMessage = "Participant " + this.pid;
      }
      SIZE = size;
      _.extend(this, config);
      checkObj(this);
      if (this.stateLabels === 'reward') {
        this.stateLabels = this.stateRewards;
      }
      this.stateLabels[0] = '';
      if (this.energyLimit) {
        leftMessage = 'Energy: <b><span id=mouselab-energy/></b>';
        if (this._block.energyLeft == null) {
          this._block.energyLeft = this.energyLimit;
        }
      } else {
        leftMessage = "Round " + (this._block.trialCount + 1) + "/" + this._block.timeline.length;
      }
      this.data = {
        stateRewards: this.stateRewards,
        trial_id: trial_id,
        block: blockName,
        trialIndex: this.trialIndex,
        score: 0,
        simulationMode: [],
        rewards: [],
        path: [],
        rt: [],
        actions: [],
        actionTimes: [],
        queries: {
          click: {
            state: {
              'target': [],
              'time': []
            },
            edge: {
              'target': [],
              'time': []
            }
          },
          mouseover: {
            state: {
              'target': [],
              'time': []
            },
            edge: {
              'target': [],
              'time': []
            }
          },
          mouseout: {
            state: {
              'target': [],
              'time': []
            },
            edge: {
              'target': [],
              'time': []
            }
          }
        }
      };
      if ($('#mouselab-msg-right').length) {
        this.leftMessage = $('#mouselab-msg-left');
        this.leftMessage.html(leftMessage);
        this.centerMessage = $('#mouselab-msg-center');
        this.centerMessage.html(centerMessage);
        this.rightMessage = $('#mouselab-msg-right');
        this.rightMessage.html(rightMessage);
        this.stage = $('#mouselab-stage');
        this.prompt = $('#mouselab-prompt');
        this.prompt.html(prompt);
      } else {
        this.display.empty();
        this.leftMessage = $('<div>', {
          id: 'mouselab-msg-left',
          "class": 'mouselab-header',
          html: leftMessage
        }).appendTo(this.display);
        this.centerMessage = $('<div>', {
          id: 'mouselab-msg-center',
          "class": 'mouselab-header',
          html: centerMessage
        }).appendTo(this.display);
        this.rightMessage = $('<div>', {
          id: 'mouselab-msg-right',
          "class": 'mouselab-header',
          html: rightMessage
        }).appendTo(this.display);
        if (prompt !== null) {
          this.prompt = $('<div>', {
            id: 'mouselab-prompt',
            "class": 'mouselab-prompt',
            html: prompt
          }).appendTo(this.display);
        }
        this.stage = $('<div>', {
          id: 'mouselab-stage'
        }).appendTo(this.display);
        if (this.timeLimit) {
          TIME_LEFT = this.timeLimit;
        }
        this.addScore(this.startScore);
      }
      this.canvasElement = $('<canvas>', {
        id: 'mouselab-canvas'
      }).attr({
        width: 500,
        height: 500
      }).appendTo(this.stage);
      this.lowerMessage = $('<div>', {
        id: 'mouselab-msg-bottom',
        "class": 'mouselab-msg-bottom',
        html: lowerMessage || '&nbsp'
      }).appendTo(this.stage);
      this.waitMessage = $('<div>', {
        id: 'mouselab-wait-msg',
        "class": 'mouselab-msg-bottom'
      }).appendTo(this.display);
      this.waitMessage.hide();
      this.defaultLowerMessage = lowerMessage;
      $('#jspsych-target').append("<div id=\"mdp-feedback\" class=\"modal\">\n  <div id=\"mdp-feedback-content\" class=\"modal-content\">\n    <h3>Default</h3>\n  </div>\n</div>");
      mdp = this;
      LOG_INFO('new MouselabMDP', this);
      this.invKeys = _.invert(this.keys);
      this.resetScore();
      this.spendEnergy(0);
      this.freeze = false;
      this.lowerMessage.css('color', '#000');
    }

    MouselabMDP.prototype.runDemo = function() {
      var a, c, i, j, len, len1, ref, ref1, results, s;
      this.timeLeft = 1;
      console.log('runDemo');
      ref = this.clicks;
      for (i = 0, len = ref.length; i < len; i++) {
        c = ref[i];
        await(sleep(1000));
        console.log('click', c);
        this.clickState(this.states[c], c);
        this.canvas.renderAll();
      }
      ref1 = this.actions;
      results = [];
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        a = ref1[j];
        await(sleep(700));
        s = _.last(this.data.path);
        results.push(this.handleKey(s, a));
      }
      return results;
    };

    MouselabMDP.prototype.startTimer = function() {
      var interval;
      this.timeLeft = this.minTime;
      this.waitMessage.html("Please wait " + this.timeLeft + " seconds");
      interval = ifvisible.onEvery(1, (function(_this) {
        return function() {
          if (_this.freeze) {
            return;
          }
          _this.timeLeft -= 1;
          _this.waitMessage.html("Please wait " + _this.timeLeft + " seconds");
          if (_this.timeLeft === 0) {
            interval.stop();
            return _this.checkFinished();
          }
        };
      })(this));
      $('#mdp-time').html(this.timeLeft);
      return $('#mdp-time').css('color', redGreen(-this.timeLeft + .1));
    };

    MouselabMDP.prototype.endBlock = function() {
      this.blockOver = true;
      jsPsych.pluginAPI.cancelAllKeyboardResponses();
      return this.keyListener = jsPsych.pluginAPI.getKeyboardResponse({
        valid_responses: ['space'],
        rt_method: 'date',
        persist: false,
        allow_held_key: false,
        callback_function: (function(_this) {
          return function(info) {
            jsPsych.finishTrial(_this.data);
            _this.display.empty();
            return jsPsych.endCurrentTimeline();
          };
        })(this)
      });
    };

    MouselabMDP.prototype.handleKey = function(s0, a) {
      var _, ref, s1;
      LOG_DEBUG('handleKey', s0, a);
      if (a === 'simulate') {
        if (this.simulationMode) {
          return this.endSimulationMode();
        } else {
          return this.startSimulationMode();
        }
      } else {
        if (!this.simulationMode) {
          this.allowSimulation = false;
          if (this.defaultLowerMessage) {
            this.lowerMessage.html('Move with the arrow keys.');
            this.lowerMessage.css('color', '#000');
          }
        }
        this.data.actions.push(a);
        this.data.simulationMode.push(this.simulationMode);
        this.data.actionTimes.push(Date.now() - this.initTime);
        ref = this.graph[s0][a], _ = ref[0], s1 = ref[1];
        return this.move(s0, a, s1);
      }
    };

    MouselabMDP.prototype.startSimulationMode = function() {
      this.simulationMode = true;
      this.player.set('top', this.states[this.initial].top - 20).set('left', this.states[this.initial].left);
      this.player.set('opacity', 0.4);
      this.canvas.renderAll();
      this.arrive(this.initial);
      this.rightMessage.html('Ghost Score: <span id=mouselab-score/>');
      this.resetScore();
      this.drawScore(this.data.score);
      return this.lowerMessage.html("<b>ðŸ‘» Ghost Mode ðŸ‘»</b>\n<br>\nPress <code>space</code> to return to your corporeal form.");
    };

    MouselabMDP.prototype.endSimulationMode = function() {
      this.simulationMode = false;
      this.player.set('top', this.states[this.initial].top).set('left', this.states[this.initial].left);
      this.player.set('opacity', 1);
      this.canvas.renderAll();
      this.arrive(this.initial);
      this.centerMessage.html('');
      this.rightMessage.html(RIGHT_MESSAGE);
      this.resetScore();
      return this.lowerMessage.html(this.defaultLowerMessage);
    };

    MouselabMDP.prototype.getOutcome = function(s0, a) {
      var r, ref, s1;
      LOG_DEBUG("getOutcome " + s0 + ", " + a);
      ref = this.graph[s0][a], s1 = ref[0], r = ref[1];
      if (this.stateRewards != null) {
        r = this.stateRewards[s1];
      }
      return [r, s1];
    };

    MouselabMDP.prototype.encodeBelief = function() {
      var b;
      b = _.values(this.states).map((function(_this) {
        return function(g) {
          return g.label.text || '_';
        };
      })(this));
      b[0] = 0;
      return b.join(' ');
    };

    MouselabMDP.prototype.getReward = function(s0, a, s1) {
      if (this.stateRewards != null) {
        return this.stateRewards[s1];
      } else {
        return this.graph[s0][a];
      }
    };

    MouselabMDP.prototype.move = function(s0, a, s1) {
      var nClick, newTop, notEnoughClicks, r, s1g;
      if (!this.moved) {
        await(this.showFeedback(this.termAction));
      }
      this.moved = true;
      if (this.freeze) {
        LOG_INFO('freeze!');
        this.arrive(s0, 'repeat');
        return;
      }
      nClick = this.data.queries.click.state.target.length;
      notEnoughClicks = (this.special.startsWith('trainClick')) && nClick < 3;
      if (notEnoughClicks) {
        this.lowerMessage.html('<b>Inspect at least three nodes before moving!</b>');
        this.lowerMessage.css('color', '#FC4754');
        this.special = 'trainClickBlock';
        this.arrive(s0, 'repeat');
        return;
      }
      r = this.getReward(s0, a, s1);
      LOG_DEBUG("move " + s0 + ", " + s1 + ", " + r);
      s1g = this.states[s1];
      this.freeze = true;
      newTop = this.simulationMode ? s1g.top - 20 : s1g.top + TOP_ADJUST;
      return this.player.animate({
        left: s1g.left,
        top: newTop
      }, {
        duration: this.moveDelay,
        onChange: this.canvas.renderAll.bind(this.canvas),
        onComplete: (function(_this) {
          return function() {
            _this.data.rewards.push(r);
            _this.addScore(r);
            _this.spendEnergy(_this.moveEnergy);
            return _this.arrive(s1);
          };
        })(this)
      });
    };

    MouselabMDP.prototype.clickState = function(g, s) {
      var r;
      LOG_INFO("clickState " + s);
      if (this.moved) {
        this.lowerMessage.html("<b>You can't use the node inspector after moving!</b>");
        this.lowerMessage.css('color', '#FC4754');
        return;
      }
      if (this.complete || (("" + s) === ("" + this.initial)) || this.freeze) {
        return;
      }
      if (this.special === 'trainClickBlock' && this.data.queries.click.state.target.length === 2) {
        this.lowerMessage.html('<b>Nice job! You can click on more nodes or start moving.</b>');
        this.lowerMessage.css('color', '#000');
      }
      if (this.stateLabels && this.stateDisplay === 'click' && !g.label.text) {
        await(this.showFeedback(s));
        this.addScore(-this.stateClickCost);
        this.recordQuery('click', 'state', s);
        this.spendEnergy(this.clickEnergy);
        r = this.stateLabels[s];
        if (this.clickDelay) {
          this.freeze = true;
          g.setLabel('...');
          await(sleep(this.clickDelay()));
          this.freeze = false;
        }
        g.setLabel(r);
        return this.canvas.renderAll();
      }
    };

    MouselabMDP.prototype.showFeedback = function(action) {
      var a, defaultMessage, delay, i, j, len, len1, loss, msg, optimal, q, qs, ref, ref1, s, strictness, v;
      console.log('showFeedback');
      qs = this.qs[this.encodeBelief()];
      v = _.max(qs);
      optimal = (function() {
        var results;
        results = [];
        for (a in qs) {
          q = qs[a];
          if (v - q < .01) {
            results.push(a);
          }
        }
        return results;
      })();
      this.freeze = true;
      strictness = 1;
      loss = v - qs[action];
      if (loss > 0) {
        delay = 2 + Math.round(strictness * loss);
      } else {
        delay = 0;
      }
      if (this._block.show_feedback) {
        defaultMessage = "";
        this.prompt.html(defaultMessage);
        if (loss === 0) {
          this.prompt.html("<div align='center' style='color:#008800; font-weight:bold; font-size:18pt'>\nGood job!\n</div>");
        } else {
          if (ref = this.termAction, indexOf.call(optimal, ref) >= 0) {
            msg = "You shouldn't have inspected any more nodes.";
          } else {
            msg = "You should have inspected one of the highlighted nodes.          ";
            for (i = 0, len = optimal.length; i < len; i++) {
              a = optimal[i];
              this.states[a].circle.set('fill', '#49f');
              this.canvas.renderAll();
            }
            msg += "<br> Please wait " + delay + " seconds.";
            this.prompt.html("<div align='center' style='color:#FF0000; font-weight:bold; font-size:18pt'>\n" + msg + "\n</div>");
            await(sleep(delay * 1000));
            this.prompt.html(defaultMessage);
          }
        }
      } else {
        console.log('no');
      }
      this.freeze = false;
      if (ref1 = this.termAction, indexOf.call(optimal, ref1) < 0) {
        for (j = 0, len1 = optimal.length; j < len1; j++) {
          s = optimal[j];
          this.states[s].circle.set('fill', '#bbb');
        }
        return this.canvas.renderAll();
      }
    };

    MouselabMDP.prototype.mouseoverState = function(g, s) {
      if (this.stateLabels && this.stateDisplay === 'hover') {
        g.setLabel(this.stateLabels[s]);
        return this.recordQuery('mouseover', 'state', s);
      }
    };

    MouselabMDP.prototype.mouseoutState = function(g, s) {
      if (this.stateLabels && this.stateDisplay === 'hover') {
        g.setLabel('');
        return this.recordQuery('mouseout', 'state', s);
      }
    };

    MouselabMDP.prototype.clickEdge = function(g, s0, r, s1) {
      var ref;
      if (!this.complete && g.label.text === '?') {
        LOG_DEBUG("clickEdge " + s0 + " " + r + " " + s1);
        if (this.edgeLabels && this.edgeDisplay === 'click' && ((ref = g.label.text) === '?' || ref === '')) {
          g.setLabel(this.getEdgeLabel(s0, r, s1));
          return this.recordQuery('click', 'edge', s0 + "__" + s1);
        }
      }
    };

    MouselabMDP.prototype.mouseoverEdge = function(g, s0, r, s1) {
      if (this.edgeLabels && this.edgeDisplay === 'hover') {
        g.setLabel(this.getEdgeLabel(s0, r, s1));
        return this.recordQuery('mouseover', 'edge', s0 + "__" + s1);
      }
    };

    MouselabMDP.prototype.mouseoutEdge = function(g, s0, r, s1) {
      if (this.edgeLabels && this.edgeDisplay === 'hover') {
        g.setLabel('');
        return this.recordQuery('mouseout', 'edge', s0 + "__" + s1);
      }
    };

    MouselabMDP.prototype.getEdgeLabel = function(s0, r, s1) {
      if (this.edgeLabels === 'reward') {
        return 'Â®';
      } else {
        return this.edgeLabels[s0 + "__" + s1];
      }
    };

    MouselabMDP.prototype.recordQuery = function(queryType, targetType, target) {
      this.canvas.renderAll();
      this.data.queries[queryType][targetType].target.push(target);
      return this.data.queries[queryType][targetType].time.push(Date.now() - this.initTime);
    };

    MouselabMDP.prototype.arrive = function(s, repeat) {
      var a, g, keys;
      if (repeat == null) {
        repeat = false;
      }
      g = this.states[s];
      g.setLabel(this.stateRewards[s]);
      this.canvas.renderAll();
      this.freeze = false;
      LOG_DEBUG('arrive', s);
      if (!repeat) {
        this.data.path.push(s);
      }
      if (this.graph[s]) {
        keys = (function() {
          var i, len, ref, results;
          ref = Object.keys(this.graph[s]);
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            a = ref[i];
            results.push(this.keys[a]);
          }
          return results;
        }).call(this);
      } else {
        keys = [];
      }
      if (this.allowSimulation) {
        keys.push('space');
      }
      if (!keys.length) {
        this.complete = true;
        this.checkFinished();
        return;
      }
      if (!mdp.showParticipant) {
        return this.keyListener = jsPsych.pluginAPI.getKeyboardResponse({
          valid_responses: keys,
          rt_method: 'date',
          persist: false,
          allow_held_key: false,
          callback_function: (function(_this) {
            return function(info) {
              var action;
              action = _this.invKeys[info.key];
              LOG_DEBUG('key', info.key);
              _this.data.rt.push(info.rt);
              return _this.handleKey(s, action);
            };
          })(this)
        });
      }
    };

    MouselabMDP.prototype.addScore = function(v) {
      var score;
      this.data.score += v;
      if (this.simulationMode) {
        score = this.data.score;
      } else {
        SCORE += v;
        score = SCORE;
      }
      return this.drawScore(score);
    };

    MouselabMDP.prototype.resetScore = function() {
      this.data.score = 0;
      return this.drawScore(SCORE);
    };

    MouselabMDP.prototype.drawScore = function(score) {
      $('#mouselab-score').html('$' + score);
      return $('#mouselab-score').css('color', redGreen(score));
    };

    MouselabMDP.prototype.spendEnergy = function(v) {
      this._block.energyLeft -= v;
      if (this._block.energyLeft <= 0) {
        LOG_INFO('OUT OF ENERGY');
        this._block.energyLeft = 0;
        this.freeze = true;
        this.lowerMessage.html("<b>You're out of energy! Press</b> <code>space</code> <b>to continue.</br>");
        this.endBlock();
      }
      return $('#mouselab-energy').html(this._block.energyLeft);
    };

    MouselabMDP.prototype.run = function() {
      jsPsych.pluginAPI.cancelAllKeyboardResponses();
      LOG_DEBUG('run');
      this.buildMap();
      if (this.timeLimit || this.minTime) {
        this.startTimer();
      }
      fabric.Image.fromURL(this.playerImage, ((function(_this) {
        return function(img) {
          _this.initPlayer(img);
          _this.canvas.renderAll();
          _this.initTime = Date.now();
          return _this.arrive(_this.initial);
        };
      })(this)));
      if (this.showParticipant) {
        return this.runDemo();
      }
    };

    MouselabMDP.prototype.draw = function(obj) {
      this.canvas.add(obj);
      return obj;
    };

    MouselabMDP.prototype.initPlayer = function(img) {
      var left, top;
      LOG_DEBUG('initPlayer');
      top = this.states[this.initial].top + TOP_ADJUST;
      left = this.states[this.initial].left;
      img.scale(0.25);
      img.set('top', top).set('left', left);
      this.draw(img);
      return this.player = img;
    };

    MouselabMDP.prototype.buildMap = function() {
      var a, actions, height, location, maxx, maxy, minx, miny, r, ref, ref1, ref2, ref3, results, s, s0, s1, width, x, xs, y, ys;
      ref = _.unzip(_.values(this.layout)), xs = ref[0], ys = ref[1];
      minx = _.min(xs);
      miny = _.min(ys);
      maxx = _.max(xs);
      maxy = _.max(ys);
      ref1 = [maxx - minx + 1, maxy - miny + 1], width = ref1[0], height = ref1[1];
      this.canvasElement.attr({
        width: width * SIZE,
        height: height * SIZE
      });
      this.canvas = new fabric.Canvas('mouselab-canvas', {
        selection: false
      });
      this.canvas.defaultCursor = 'pointer';
      this.states = {};
      ref2 = removePrivate(this.layout);
      for (s in ref2) {
        location = ref2[s];
        x = location[0], y = location[1];
        this.states[s] = new State(s, x - minx, y - miny, {
          fill: '#bbb',
          label: this.stateDisplay === 'always' ? this.stateLabels[s] : ''
        });
      }
      ref3 = removePrivate(this.graph);
      results = [];
      for (s0 in ref3) {
        actions = ref3[s0];
        results.push((function() {
          var ref4, results1;
          results1 = [];
          for (a in actions) {
            ref4 = actions[a], r = ref4[0], s1 = ref4[1];
            results1.push(new Edge(this.states[s0], r, this.states[s1], {
              label: this.edgeDisplay === 'always' ? this.getEdgeLabel(s0, r, s1) : ''
            }));
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    MouselabMDP.prototype.endTrial = function() {
      window.clearInterval(this.timerID);
      if (this.blockOver) {
        return;
      }
      this.lowerMessage.html("You made <span class=mouselab-score/> on this round.\n<br>\n<b>Press</b> <code>space</code> <b>to continue.</b>");
      $('.mouselab-score').html('$' + this.data.score);
      $('.mouselab-score').css('color', redGreen(this.data.score));
      $('.mouselab-score').css('font-weight', 'bold');
      return this.keyListener = jsPsych.pluginAPI.getKeyboardResponse({
        valid_responses: ['space'],
        rt_method: 'date',
        persist: false,
        allow_held_key: false,
        callback_function: (function(_this) {
          return function(info) {
            _this.data.trialTime = getTime() - _this.initTime;
            jsPsych.finishTrial(_this.data);
            return _this.stage.empty();
          };
        })(this)
      });
    };

    MouselabMDP.prototype.checkFinished = function() {
      if (this.complete) {
        if (this.timeLeft != null) {
          if (this.timeLeft > 0) {
            return this.waitMessage.show();
          } else {
            this.waitMessage.hide();
            return this.endTrial();
          }
        } else {
          return this.endTrial();
        }
      }
    };

    return MouselabMDP;

  })();
  State = (function() {
    function State(name, left, top, config) {
      var conf;
      this.name = name;
      if (config == null) {
        config = {};
      }
      left = (left + 0.5) * SIZE;
      top = (top + 0.5) * SIZE;
      this.left = left;
      this.top = top;
      conf = {
        left: left,
        top: top,
        fill: '#bbbbbb',
        radius: SIZE / 4,
        label: ''
      };
      _.extend(conf, config);
      this.circle = new fabric.Circle(conf);
      this.label = {};
      this.radius = this.circle.radius;
      this.left = this.circle.left;
      this.top = this.circle.top;
      mdp.canvas.add(this.circle);
      if (!mdp.showParticipant) {
        this.circle.on('mousedown', (function(_this) {
          return function() {
            return mdp.clickState(_this, _this.name);
          };
        })(this));
        this.circle.on('mouseover', (function(_this) {
          return function() {
            return mdp.mouseoverState(_this, _this.name);
          };
        })(this));
        this.circle.on('mouseout', (function(_this) {
          return function() {
            return mdp.mouseoutState(_this, _this.name);
          };
        })(this));
      }
    }

    State.prototype.setLabel = function(txt, conf) {
      var post, pre, ref, ref1;
      if (conf == null) {
        conf = {};
      }
      this.label = new Text('----------', this.left, this.top, {
        fontSize: SIZE / 4,
        fill: '#44d'
      });
      mdp.canvas.add(this.label);
      LOG_DEBUG('setLabel', txt);
      pre = (ref = conf.pre) != null ? ref : '', post = (ref1 = conf.post) != null ? ref1 : '';
      if (txt != null) {
        this.label.setText("" + pre + txt + post);
        this.label.setFill(redGreen(txt));
      } else {
        this.label.setText('');
      }
      return this.dirty = true;
    };

    State.prototype.higlight = function() {
      return this.circle.set('color', '#49f');
    };

    return State;

  })();
  Edge = (function() {
    function Edge(c1, reward, c2, config) {
      var adjX, adjY, ang, labX, labY, label, ref, ref1, ref2, ref3, ref4, ref5, ref6, rotateLabel, spacing, x1, x2, y1, y2;
      if (config == null) {
        config = {};
      }
      spacing = (ref = config.spacing) != null ? ref : 8, adjX = (ref1 = config.adjX) != null ? ref1 : 0, adjY = (ref2 = config.adjY) != null ? ref2 : 0, rotateLabel = (ref3 = config.rotateLabel) != null ? ref3 : false, label = (ref4 = config.label) != null ? ref4 : '';
      ref5 = [c1.left + adjX, c1.top + adjY, c2.left + adjX, c2.top + adjY], x1 = ref5[0], y1 = ref5[1], x2 = ref5[2], y2 = ref5[3];
      this.arrow = new Arrow(x1, y1, x2, y2, c1.radius + spacing, c2.radius + spacing);
      ang = (this.arrow.ang + Math.PI / 2) % (Math.PI * 2);
      if ((0.5 * Math.PI <= ang && ang <= 1.5 * Math.PI)) {
        ang += Math.PI;
      }
      ref6 = polarMove(x1, y1, angle(x1, y1, x2, y2), SIZE * 0.45), labX = ref6[0], labY = ref6[1];
      this.label = new Text('----------', labX, labY, {
        angle: rotateLabel ? ang * 180 / Math.PI : 0,
        fill: redGreen(label),
        fontSize: SIZE / 4,
        textBackgroundColor: 'white'
      });
      this.arrow.on('mousedown', (function(_this) {
        return function() {
          return mdp.clickEdge(_this, c1.name, reward, c2.name);
        };
      })(this));
      this.arrow.on('mouseover', (function(_this) {
        return function() {
          return mdp.mouseoverEdge(_this, c1.name, reward, c2.name);
        };
      })(this));
      this.arrow.on('mouseout', (function(_this) {
        return function() {
          return mdp.mouseoutEdge(_this, c1.name, reward, c2.name);
        };
      })(this));
      this.setLabel(label);
      mdp.canvas.add(this.arrow);
      mdp.canvas.add(this.label);
    }

    Edge.prototype.setLabel = function(txt, conf) {
      var post, pre, ref, ref1;
      if (conf == null) {
        conf = {};
      }
      pre = (ref = conf.pre) != null ? ref : '', post = (ref1 = conf.post) != null ? ref1 : '';
      if (txt) {
        this.label.setText("" + pre + txt + post);
        this.label.setFill(redGreen(txt));
      } else {
        this.label.setText('');
      }
      return this.dirty = true;
    };

    return Edge;

  })();
  Arrow = (function(superClass) {
    extend(Arrow, superClass);

    function Arrow(x1, y1, x2, y2, adj1, adj2) {
      var ang, centerX, centerY, deltaX, deltaY, dx, dy, line, point, ref, ref1;
      if (adj1 == null) {
        adj1 = 0;
      }
      if (adj2 == null) {
        adj2 = 0;
      }
      ang = angle(x1, y1, x2, y2);
      ref = polarMove(x1, y1, ang, adj1), x1 = ref[0], y1 = ref[1];
      ref1 = polarMove(x2, y2, ang, -(adj2 + 7.5)), x2 = ref1[0], y2 = ref1[1];
      line = new fabric.Line([x1, y1, x2, y2], {
        stroke: '#555',
        selectable: false,
        strokeWidth: 3
      });
      centerX = (x1 + x2) / 2;
      centerY = (y1 + y2) / 2;
      deltaX = line.left - centerX;
      deltaY = line.top - centerY;
      dx = x2 - x1;
      dy = y2 - y1;
      point = new fabric.Triangle({
        left: x2 + deltaX,
        top: y2 + deltaY,
        pointType: 'arrow_start',
        angle: ang * 180 / Math.PI,
        width: 10,
        height: 10,
        fill: '#555'
      });
      Arrow.__super__.constructor.call(this, [line, point]);
      this.ang = ang;
      this.centerX = centerX;
      this.centerY = centerY;
    }

    return Arrow;

  })(fabric.Group);
  Text = (function(superClass) {
    extend(Text, superClass);

    function Text(txt, left, top, config) {
      var conf;
      txt = String(txt);
      conf = {
        left: left,
        top: top,
        fontFamily: 'helvetica',
        fontSize: SIZE / 8
      };
      _.extend(conf, config);
      Text.__super__.constructor.call(this, txt, conf);
    }

    return Text;

  })(fabric.Text);
  plugin = {
    trial: function(display_element, trialConfig) {
      var trial;
      trialConfig.display = display_element;
      LOG_INFO('trialConfig', trialConfig);
      trial = new MouselabMDP(trialConfig);
      trial.run();
      if (trialConfig._block) {
        trialConfig._block.trialCount += 1;
      }
      return TRIAL_INDEX += 1;
    }
  };
  return plugin;
})();
