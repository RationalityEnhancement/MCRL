// Generated by CoffeeScript 1.12.3

/*
jspsych-plane.coffee
Fred Callaway

An MDP game in which the participant plans flights to
maximize profit.
 */
var canvas, game, locations,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

locations = void 0;

canvas = void 0;

game = void 0;

jsPsych.plugins['plane'] = (function() {
  var Arrow, Connection, DEBUG, Location, PlaneGame, Text, add, angle, dist, plugin, polarMove, s;
  DEBUG = console.log;
  s = void 0;
  canvas = void 0;
  fabric.Object.prototype.originX = fabric.Object.prototype.originY = 'center';
  fabric.Object.prototype.selectable = false;
  fabric.Object.prototype.hoverCursor = 'plain';
  angle = function(x1, y1, x2, y2) {
    var ang, x, y;
    x = x2 - x1;
    y = y2 - y1;
    if (x === 0) {
      ang = y === 0 ? 0 : y > 0 ? Math.PI / 2 : Math.PI * 3 / 2;
    } else if (y === 0) {
      ang = x > 0 ? 0 : Math.PI;
    } else {
      ang = x < 0 ? Math.atan(y / x) + Math.PI : y < 0 ? Math.atan(y / x) + 2 * Math.PI : Math.atan(y / x);
    }
    return ang + Math.PI / 2;
  };
  polarMove = function(x, y, ang, dist) {
    x += dist * Math.sin(ang);
    y -= dist * Math.cos(ang);
    return [x, y];
  };
  add = function(obj) {
    canvas.add(obj);
    return obj;
  };
  dist = function(o1, o2) {
    return Math.pow(Math.pow(o1.left - o2.left, 2) + Math.pow(o1.top - o2.top, 2), 0.5);
  };
  PlaneGame = (function() {
    function PlaneGame(config) {
      this.buildMap = bind(this.buildMap, this);
      this.run = bind(this.run, this);
      this.endTrial = bind(this.endTrial, this);
      this.move = bind(this.move, this);
      this.updateCounters = bind(this.updateCounters, this);
      var height, lowerMessage, pr_depth, pseudo_html, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, stim, width;
      this.display = config.display, this.initial = config.initial, this.graph = config.graph, this.final = (ref = config.final) != null ? ref : [], this.pseudo = (ref1 = config.pseudo) != null ? ref1 : null, this.depth = (ref2 = config.depth) != null ? ref2 : null, this.width = (ref3 = config.width) != null ? ref3 : null, this.layout = (ref4 = config.layout) != null ? ref4 : 'ring', this.n_moves = (ref5 = config.n_moves) != null ? ref5 : null, this.pTerm = (ref6 = config.pTerm) != null ? ref6 : 0, lowerMessage = (ref7 = config.lowerMessage) != null ? ref7 : 'Control the plane by clicking on the next destination.', stim = config.stim, pr_depth = config.pr_depth;
      this.data = {
        path: [this.initial]
      };
      this.score = 0;
      this.pseudoScore = 0;
      this.noInput = false;
      this.movesLeft = this.n_moves;
      this.progressCounter = $('<div>', {
        id: 'plane-progress-counter',
        "class": 'plane-header',
        html: '&nbsp'
      }).appendTo(this.display);
      this.moveCounter = $('<div>', {
        id: 'plane-move-counter',
        "class": 'plane-header',
        html: 'Moves: <span id=plane-moves/>'
      }).appendTo(this.display);
      if (this.movesLeft == null) {
        this.moveCounter.html('&nbsp');
      }
      pseudo_html = this.pseudo != null ? 'Stars: <span id=plane-pseudo/>' : '&nbsp';
      this.pseudoCounter = $('<div>', {
        id: 'plane-pseudo-counter',
        "class": 'plane-header',
        html: pseudo_html
      }).appendTo(this.display);
      this.scoreCounter = $('<div>', {
        id: 'plane-score-counter',
        "class": 'plane-header',
        html: 'Profit: <span id=plane-score/>'
      }).appendTo(this.display);
      switch (this.layout) {
        case 'ring':
          s = 100;
          this.width = 5.5;
          this.height = 4;
          width = this.width * s;
          height = this.height * s;
          break;
        case 'pachinko':
          s = 140;
          width = this.depth * s;
          height = (this.width + .5) * s;
      }
      this.canvas = $('<canvas>', {
        id: 'plane-canvas'
      }).attr({
        width: width,
        height: height
      }).appendTo(this.display);
      this.lowerMessage = $('<div>', {
        id: 'plane-lower-message',
        html: lowerMessage || '&nbsp'
      }).appendTo(this.display);
      this.updateCounters();
      canvas = new fabric.Canvas('plane-canvas', {
        selection: false
      });
      game = this;
      this.data = {
        width: this.width,
        height: this.height,
        stim: stim,
        pr_depth: pr_depth,
        path: []
      };
      checkObj(this);
      console.log('new PlaneGame', this);
    }

    PlaneGame.prototype.updateCounters = function() {
      var color;
      this.progressCounter.html("Trial: 1 / 1");
      $('#plane-score').html('$' + this.score);
      $('#plane-pseudo').html('⭐' + this.pseudoScore);
      color = this.score === 0 ? 'gray' : this.score < 0 ? 'red' : 'green';
      $('#plane-score').css('color', color);
      return $('#plane-moves').html(this.movesLeft);
    };

    PlaneGame.prototype.updatePseudo = function() {
      var i, len, loc, pr, pseudo, ref;
      if (this.pseudo == null) {
        return;
      }
      if (this.nextPseudo) {
        pr = this.nextPseudo[this.plane.location];
        if (pr != null) {
          this.pseudoScore += pr;
        } else {
          return;
        }
      }
      this.nextPseudo = {};
      pseudo = this.pseudo[this.plane.location];
      ref = this.locations;
      for (i = 0, len = ref.length; i < len; i++) {
        loc = ref[i];
        pr = pseudo[loc.name];
        if (pr != null) {
          this.nextPseudo[loc.name] = pr;
        } else {
          pr = '';
        }
        loc.setLabel(String(pr));
      }
      return canvas.renderAll();
    };

    PlaneGame.prototype.move = function(loc) {
      var connections, dest, i, len, r, ref, results, source;
      if (this.noInput) {
        return;
      }
      source = this.plane.location;
      connections = this.graph[source][1];
      results = [];
      for (i = 0, len = connections.length; i < len; i++) {
        ref = connections[i], dest = ref[0], r = ref[1];
        if (this.plane.location === source && loc.name === dest) {
          this.data.path.push(dest);
          this.noInput = true;
          this.movesLeft -= 1;
          this.plane.location = loc.name;
          this.score += r;
          results.push(this.plane.animate({
            left: loc.left,
            top: loc.top
          }, {
            duration: dist(this.plane, loc) * 4,
            onChange: canvas.renderAll.bind(canvas),
            onComplete: (function(_this) {
              return function() {
                _this.updatePseudo();
                _this.updateCounters();
                _this.noInput = false;
                if (Math.random() < _this.pTerm || _this.movesLeft === 0 || indexOf.call(_this.final, dest) >= 0) {
                  return _this.endTrial();
                }
              };
            })(this)
          }));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    PlaneGame.prototype.endTrial = function() {
      console.log('endTrial');
      this.data.score = this.score;
      this.lowerMessage.html("Well done! Click Continue to move on.<br>");
      return $('<button>').addClass('btn btn-primary btn-lg').text('Continue').click(((function(_this) {
        return function() {
          _this.display.empty();
          return jsPsych.finishTrial(_this.data);
        };
      })(this))).appendTo(this.lowerMessage);
    };

    PlaneGame.prototype.run = function() {
      this.buildMap();
      return fabric.Image.fromURL('/static/images/plane.png', ((function(_this) {
        return function(img) {
          var left, top;
          top = _this.locations[_this.initial].top;
          left = _this.locations[_this.initial].left;
          img.scale(0.35);
          img.set('top', top).set('left', left);
          add(img);
          img.set('top', top).set('left', left);
          canvas.renderAll();
          _this.plane = img;
          _this.plane.location = _this.initial;
          return _this.updatePseudo();
        };
      })(this)));
    };

    PlaneGame.prototype.buildMap = function() {
      var adj, connections, d, i, j, k, len, ref, ref1, ref2, ref3, results, reward, source, target, w;
      switch (this.layout) {
        case 'ring':
          this.locations = [add(new Location(0, 1, this.height / 2)), add(new Location(1, 2, this.height / 2 - 1)), add(new Location(2, 3.5, this.height / 2 - 1)), add(new Location(3, 4.5, this.height / 2)), add(new Location(4, 3.5, this.height / 2 + 1)), add(new Location(5, 2, this.height / 2 + 1))];
          break;
        case 'pachinko':
          this.locations = [];
          for (d = i = 0, ref = this.depth; 0 <= ref ? i < ref : i > ref; d = 0 <= ref ? ++i : --i) {
            for (w = j = 0, ref1 = this.width; 0 <= ref1 ? j < ref1 : j > ref1; w = 0 <= ref1 ? ++j : --j) {
              adj = d % 2 ? 0.5 : 0;
              this.locations.push(add(new Location(d * this.width + w, 0.5 + d, 1 + w - adj)));
            }
          }
          break;
        default:
          throw new Error("Bad layout " + this.layout);
      }
      console.log('@locations', this.locations);
      ref2 = this.graph;
      results = [];
      for (k = 0, len = ref2.length; k < len; k++) {
        ref3 = ref2[k], source = ref3[0], connections = ref3[1];
        results.push((function() {
          var l, len1, ref4, results1;
          results1 = [];
          for (l = 0, len1 = connections.length; l < len1; l++) {
            ref4 = connections[l], target = ref4[0], reward = ref4[1];
            results1.push(add(new Connection(this.locations[source], this.locations[target], {
              reward: reward
            })));
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    return PlaneGame;

  })();
  Location = (function(superClass) {
    extend(Location, superClass);

    function Location(name, left, top, config) {
      var conf;
      this.name = name;
      if (config == null) {
        config = {};
      }
      left *= s;
      top *= s;
      conf = {
        left: left,
        top: top,
        fill: '#bbbbbb',
        radius: s / 6,
        hoverCursor: 'pointer',
        label: ''
      };
      _.extend(conf, config);
      this.on('mousedown', function() {
        return game.move(this);
      });
      this.circle = new fabric.Circle(conf);
      this.label = new Text(conf.label, left, top, {
        fontSize: 20,
        fill: '#44d'
      });
      this.radius = this.circle.radius;
      this.left = this.circle.left;
      this.top = this.circle.top;
      Location.__super__.constructor.call(this, [this.circle, this.label]);
    }

    Location.prototype.setLabel = function(txt) {
      this.label.setText(txt);
      return this.dirty = true;
    };

    return Location;

  })(fabric.Group);
  Connection = (function(superClass) {
    extend(Connection, superClass);

    function Connection(c1, c2, conf) {
      var adjX, adjY, ang, fill, labX, labY, label2, pseudo, ref, ref1, ref2, ref3, ref4, ref5, ref6, reward, spacing, txt, x1, x2, y1, y2;
      if (conf == null) {
        conf = {};
      }
      reward = conf.reward, pseudo = (ref = conf.pseudo) != null ? ref : null, label2 = (ref1 = conf.label2) != null ? ref1 : '', spacing = (ref2 = conf.spacing) != null ? ref2 : 8, adjX = (ref3 = conf.adjX) != null ? ref3 : 0, adjY = (ref4 = conf.adjY) != null ? ref4 : 0;
      ref5 = [c1.left + adjX, c1.top + adjY, c2.left + adjX, c2.top + adjY], x1 = ref5[0], y1 = ref5[1], x2 = ref5[2], y2 = ref5[3];
      this.arrow = new Arrow(x1, y1, x2, y2, c1.radius + spacing, c2.radius + spacing);
      ang = (this.arrow.ang + Math.PI / 2) % (Math.PI * 2);
      if ((0.5 * Math.PI <= ang && ang <= 1.5 * Math.PI)) {
        ang += Math.PI;
      }
      ref6 = polarMove(x1, y1, angle(x1, y1, x2, y2), s * 0.5), labX = ref6[0], labY = ref6[1];
      fill = reward > 0 ? '#080' : reward < 0 ? '#b00' : reward === 0 ? '#333' : void 0;
      txt = ("$" + reward) + (pseudo != null ? " + " + pseudo + "⭐️" : '');
      this.label = new Text(txt, labX, labY, {
        angle: ang * 180 / Math.PI,
        fill: fill,
        fontSize: 20,
        textBackgroundColor: 'white'
      });
      Connection.__super__.constructor.call(this, [this.arrow, this.label]);
    }

    return Connection;

  })(fabric.Group);
  Arrow = (function(superClass) {
    extend(Arrow, superClass);

    function Arrow(x1, y1, x2, y2, adj1, adj2) {
      var ang, deltaX, deltaY, dx, dy, line, point, ref, ref1;
      if (adj1 == null) {
        adj1 = 0;
      }
      if (adj2 == null) {
        adj2 = 0;
      }
      this.ang = ang = angle(x1, y1, x2, y2);
      ref = polarMove(x1, y1, ang, adj1), x1 = ref[0], y1 = ref[1];
      ref1 = polarMove(x2, y2, ang, -(adj2 + 7.5)), x2 = ref1[0], y2 = ref1[1];
      line = new fabric.Line([x1, y1, x2, y2], {
        stroke: '#000',
        selectable: false,
        strokeWidth: 3
      });
      this.centerX = (x1 + x2) / 2;
      this.centerY = (y1 + y2) / 2;
      deltaX = line.left - this.centerX;
      deltaY = line.top - this.centerY;
      dx = x2 - x1;
      dy = y2 - y1;
      point = new fabric.Triangle({
        left: x2 + deltaX,
        top: y2 + deltaY,
        pointType: 'arrow_start',
        angle: ang * 180 / Math.PI,
        width: 10,
        height: 10,
        fill: '#000'
      });
      Arrow.__super__.constructor.call(this, [line, point]);
    }

    return Arrow;

  })(fabric.Group);
  Text = (function(superClass) {
    extend(Text, superClass);

    function Text(txt, left, top, config) {
      var conf;
      txt = String(txt);
      conf = {
        left: left,
        top: top,
        fontFamily: 'helvetica',
        fontSize: 14
      };
      _.extend(conf, config);
      Text.__super__.constructor.call(this, txt, conf);
    }

    return Text;

  })(fabric.Text);
  plugin = {};
  plugin.trial = function(display_element, trial_config) {
    var trial;
    display_element.empty();
    trial_config = jsPsych.pluginAPI.evaluateFunctionParameters(trial_config);
    trial_config['display'] = display_element;
    _.extend(trial_config, loadJson(trial_config.stim));
    console.log('trial_config', trial_config);
    trial = new PlaneGame(trial_config);
    window.trial = trial;
    return trial.run();
  };
  return plugin;
})();
